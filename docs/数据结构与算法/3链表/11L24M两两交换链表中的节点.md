# ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

[ğŸ”— LeetCode](https://leetcode.cn/problems/swap-nodes-in-pairs/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚

**ç¤ºä¾‹** 1ï¼š

```js
è¾“å…¥ï¼šhead = [1,2,3,4]
è¾“å‡ºï¼š[2,1,4,3]
```

**ç¤ºä¾‹** 2ï¼š

```js
è¾“å…¥ï¼šhead = []
è¾“å‡ºï¼š[]
```

**ç¤ºä¾‹** 3ï¼š

```js
è¾“å…¥ï¼šhead = [1]
è¾“å‡ºï¼š[1]
```

**è¯´æ˜**ï¼š

- é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®åœ¨èŒƒå›´ [0, 100] å†…
- 0 <= Node.val <= 100

## è§£é¢˜æ€è·¯

é¢˜ç›®ä¿¡æ¯ï¼šèŠ‚ç‚¹äº¤æ¢

### æ€è·¯ä¸€

å“ˆå¸Œå­˜å‚¨ï¼Œå–å‡ºæ—¶æ‹¿å‡ºä¸¤ä¸ªå¹¶æ›¿æ¢é¡ºåºï¼Œå¤æ‚åº¦ O(n),O(n)

### æ€è·¯äºŒ

ä¸‰æŒ‡é’ˆéå†ï¼Œå¤æ‚åº¦ O(n),O(1)

### é¦–æ¬¡ä»£ç 

```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function swapPairs(head: ListNode | null): ListNode | null {
  const hash: ListNode[] = []
  let i = head

  let virtualHead = new ListNode()
  let j = virtualHead

  while (i) {
    hash.push(i)
    i = i.next
  }

  if (hash.length < 2) return head

  while (hash.length > 1) {
    const l = hash.shift()
    const r = hash.shift()
    l.next = null
    r.next = null

    j.next = r
    r.next = l
    j = l
  }

  if (hash.length) {
    j.next = hash.shift()
  }

  return virtualHead.next
}
```

### äºŒæ¬¡ä»£ç 

```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function swapPairs(head: ListNode | null): ListNode | null {
  if (!head) return head

  let virtualHead = new ListNode()
  virtualHead.next = head

  let pre = virtualHead
  let l = head
  let r = head.next

  while (r) {
    l.next = r.next
    r.next = l
    pre.next = r

    if (l.next && l.next.next) {
      pre = l
      r = l.next.next
      l = l.next
    } else {
      break
    }
  }

  return virtualHead.next
}
```
