# 166M 分数到小数

## 解题思路

### 思路一

数学题

难点在与判断循环与找出循环小数部分，还有各种细节的处理

首先处理负值，然后用 left 和 right 分别处理小数点左右的数

hash 记录 numerator，并且记录对应在 right 的坐标，方便后面寻找循环小数部分

carry 记录除时的借位

首先如果 numerator 有值就一直循环

如果 numerator >= denominator 直接除之后加在 left 即可

反之则需要做字符串除法，避免 js 丢失小数精度的问题

另外要在除之前判断 hash[numerator]

如果有就说明进入循环，这时是第二次循环，hash[numerator]存的 index 是第一次循环小数部分开始位置

用 slice 和 index 可以将循环小数部分括起来

没有就存 right.length 即可

### 代码

```js
/**
 * @param {number} numerator
 * @param {number} denominator
 * @return {string}
 */
var fractionToDecimal = function (numerator, denominator) {
  const isNegative =
    (numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0);

  numerator = Math.abs(numerator);
  denominator = Math.abs(denominator);

  let carry = 0;
  let left = "";
  let right = "";
  const hash = {};

  while (numerator) {
    // 重复数字，代表第二次及以后循环开始
    if (hash[numerator]) {
      const index = hash[numerator];

      const value = right[index];

      return `${isNegative ? "-" : ""}${left || "0"}.${right.slice(
        0,
        index
      )}(${right.slice(index)})`;
    } else {
      // 记录该值对应的在right的索引
      hash[numerator] = right.length;
    }

    if (numerator >= denominator) {
      while (numerator >= denominator) {
        left += Math.floor(numerator / denominator);

        numerator %= denominator;
      }
    } else {
      while (numerator < denominator) {
        numerator *= 10;

        carry++;

        // 默认进位一次，如果还不能整除，额外的进位要补0
        if (carry > 1) {
          right += "0";
        }
      }

      carry = 0;

      const bit = Math.floor(numerator / denominator);

      right += bit;
      numerator %= denominator;
    }
  }

  return `${isNegative ? "-" : ""}${left || "0"}${right ? "." : ""}${right}`;
};
```
