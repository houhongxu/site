# 79M 单词搜索

## 解题思路

### 思路一

回溯

首先找到开头字母，记录一下，然后遍历开头字母开始 dfs 查找

每次查找有单独的 index 和 used 数组

dfs 首先判断边界，然后判断是否找到，是否使用，是否不符合查找，找到的话标记 res

然后记录坐标已使用，开始遍历四个方向进行 dfs 递归，然后移除坐标使用记录

### 代码

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
  const m = board.length;
  const n = board[0].length;
  const startArr = [];
  let res = false;

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (board[i][j] === word[0]) {
        startArr.push([i, j]);
      }
    }
  }

  const dfs = (x, y, index, used) => {
    // 边界判断
    if (x < 0 || x >= m || y < 0 || y >= n) return;

    // 结束判断
    if (res || used[x][y] || board[x][y] !== word[index]) return;

    // 找到判断
    if (board[x][y] === word[index] && index === word.length - 1) {
      res = true;
    }

    used[x][y] = true;

    // 上
    dfs(x - 1, y, index + 1, used);

    // 下
    dfs(x + 1, y, index + 1, used);

    // 左
    dfs(x, y - 1, index + 1, used);

    // 右
    dfs(x, y + 1, index + 1, used);

    used[x][y] = false;
  };

  for (const start of startArr) {
    const [x, y] = start;

    const used = [...new Array(m)].map((item) => [...new Array(n)]);

    // 每次用新的index和used
    dfs(x, y, 0, used);
  }

  return res;
};
```
