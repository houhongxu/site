# 46M 全排列

## 解题思路

### 思路一

排列，回溯

用 path 记录路径，通过判断 path 长度跳出递归

通过 used 记录 path 中使用过的避免重复

### 代码

```js
const result = [];
const path = [];
const used = [...new Array(nums.length)];

const dfs = () => {
  if (path.length === nums.length) {
    result.push([...path]);
    return;
  }

  for (let i = 0; i < nums.length; i++) {
    if (used[i]) {
      continue;
    }

    used[i] = true;

    path.push(nums[i]);

    dfs();

    path.pop();

    used[i] = false;
  }
};

dfs();

return result;
```
