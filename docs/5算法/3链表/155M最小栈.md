# 155M 最小栈

## 解题思路

### 思路一

实现栈，因为需要大小顺序查询 O(1)，所以需要维护一个链表

这里单向链表足够没有使用双向链表

push 时，栈操作正常，额外对链表进行遍历，维护链表保持从小到大顺序

pop 时，栈操作正常，同样维护链表删除即可

getMin 访问链表第一个节点，其他都是栈操作即可

### 代码

```js
class Node {
  constructor(val, next) {
    this.val = val;
    this.next = next;
  }
}

var MinStack = function () {
  this.stack = [];

  // 从小到大顺序
  this.virtualHead = new Node(-Math.pow(2, 31) - 1, null);
};

/**
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function (val) {
  this.stack.push(val);

  if (!this.virtualHead.next || val <= this.virtualHead.next.val) {
    const node = new Node(val, this.virtualHead.next);
    this.virtualHead.next = node;
  } else {
    let cur = this.virtualHead.next;
    let next = cur.next;

    while (cur) {
      if (!next || (val > cur.val && val <= next.val)) {
        const node = new Node(val, next);
        cur.next = node;
        break;
      }

      cur = next;
      next = next.next;
    }
  }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
  const val = this.stack.pop();

  let cur = this.virtualHead;
  let next = cur.next;

  while (next) {
    if (next.val === val) {
      cur.next = next.next;
      break;
    }

    cur = next;
    next = next.next;
  }

  return val;
};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
  return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function () {
  return this.virtualHead.next.val;
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
```
