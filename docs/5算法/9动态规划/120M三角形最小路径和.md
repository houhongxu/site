# 96M 不同的二叉搜索树

## 解题思路

### 思路一

回溯，缓存

首先通过深度层级 depth 和行坐标 index 进行递归

depth 到 triangle 底时记录最小 sum 给 result

dfs 递归 index 和 index+1，递归前 sum 加值递归够 sum 回溯减去值

剪枝是通过 cache 数组，如果缓存值不比当前 sum 加值小，就 return

### 代码

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
  let sum = 0;
  let result = Infinity;
  const cache = [...new Array(triangle.length + 1)].map((item) => [
    ...new Array(triangle[triangle.length - 1].length + 1),
  ]);

  const dfs = (index, depth) => {
    if (depth === triangle.length) {
      result = Math.min(result, sum);
      return;
    }

    // 剪枝，跳过已经过大的sum
    if (
      typeof cache[depth][index] === "number" &&
      sum + triangle[depth][index] >= cache[depth][index]
    ) {
      return;
    }

    sum += triangle[depth][index];

    cache[depth][index] = sum;

    dfs(index, depth + 1);
    dfs(index + 1, depth + 1);

    sum -= triangle[depth][index];
  };

  dfs(0, 0);

  return result;
};
```

### 思路二

动态规划

初始化就是三角左右边，只用累加即可

注意因为是等边三角形，triangle.length 既是行最大值也是列最大值

同理 i 也既是行最大值也是列最大值

方程因为上到下是 i 和 i+1，下取上就对应是 j 和 j-1

所以是
`dp[i][j] = triangle[i][j] + Math.min(dp[i - 1][j], dp[i - 1][j - 1]);`

最后用 Math.min 取 dp 最后一行和最小值

### 代码

```js
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
  // m是行最大值也是列最大值
  const m = triangle.length;

  const dp = [...new Array(m)].map((item) => new Array(m).fill(0));

  dp[0][0] = triangle[0][0];

  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + triangle[i][0];
    // i是行最大值也是列最大值
    dp[i][i] = dp[i - 1][i - 1] + triangle[i][i];

    for (let j = 1; j < i; j++) {
      // 上到下是i和i+1，下取上就对应是j和j-1
      dp[i][j] = triangle[i][j] + Math.min(dp[i - 1][j], dp[i - 1][j - 1]);
    }
  }

  return Math.min(...dp[m - 1]);
};
```
