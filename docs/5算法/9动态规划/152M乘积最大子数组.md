# 152M 乘积最大子数组

## 解题思路

### 思路一

动态规划

初始化就是第一个值，nums[0]

难点在方程上面

基础方程是 dp[i]=Math.max(dp[i-1]\*nums[i],nums[i])

就是当前乘积和当前值取最大值

但是有个问题是有可能有负数乘负数出现最大值

那么就需要记录下来负数并加入比较

那么就想到多一个 dpMin，之前的改为 dpMax

然后就是最终方程

```js
dpMax[i] = Math.max(
  dpMax[i - 1] * nums[i],
  // 最小值负数*负数可能为最大值
  dpMin[i - 1] * nums[i],
  nums[i]
);

dpMin[i] = Math.min(
  dpMin[i - 1] * nums[i],
  // 最大值正数*负数可能为最小值
  dpMax[i - 1] * nums[i],
  nums[i]
);
```

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {
  const dpMax = new Array(nums.length);
  const dpMin = new Array(nums.length);

  dpMax[0] = nums[0];
  dpMin[0] = nums[0];

  for (let i = 1; i < nums.length; i++) {
    dpMax[i] = Math.max(
      dpMax[i - 1] * nums[i],
      // 最小值负数*负数可能为最大值
      dpMin[i - 1] * nums[i],
      nums[i]
    );

    dpMin[i] = Math.min(
      dpMin[i - 1] * nums[i],
      // 最大值正数*负数可能为最小值
      dpMax[i - 1] * nums[i],
      nums[i]
    );
  }

  return Math.max(...dpMax, ...dpMin);
};
```
