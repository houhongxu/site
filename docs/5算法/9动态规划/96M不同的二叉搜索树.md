# 96M 不同的二叉搜索树

## 解题思路

### 思路一

排列，回溯

用 path 记录路径，通过判断 path 长度跳出递归

通过 used 记录 path 中使用过的避免重复

将 path 转为二叉搜索树

使用前序遍历与 hash 去重二叉搜索树

直接超时，构造树太慢了

### 思路二

动态规划

假设 dp[i]是 n 为 i 时的组合数

j 是根节点，那么 j<=i

j-1 就是左子树，i-j 就是右子树

方程就是 左子树的组合数 \* 右子树的组合数+根节点

dp[i] += dp[j - 1] \* dp[i - j];

初始化就是 0 时 1 时都是 1

### 代码

```js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
  const dp = new Array(n + 1).fill(0);

  // 0时为唯一空树
  dp[0] = 1;
  // 1时为唯一根节点树
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    // j为根节点，j-1为左子树，i-j为右子树
    for (let j = 1; j <= i; j++) {
      // 左子树的组合数 * 右子树的组合数+根节点
      dp[i] += dp[j - 1] * dp[i - j];
    }
  }

  return dp[n];
};
```
