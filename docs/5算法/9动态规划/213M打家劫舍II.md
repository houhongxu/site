# 213M 打家劫舍 II

## 解题思路

### 思路一

动态规划

因为偷第一个就不能偷最后一个

所以分两个情况 dp1 和 dp2

初始化

dp1 就是 dp1[0] dp1[1]都是 nums[0]
dp2 就是 dp2[0]是 dp2[1]是 nums[0]

方程就是选择偷上上个房子和当前房子，或者偷上一个当前房子不偷

dp[i]= Math.max(dp[i - 2] + nums[i], dp[i - 1]);

额外判断一下 dp1 在最后一个不偷，直接用上次的值

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  // 偷第一个不偷最后一个
  const dp1 = new Array(nums.length).fill(0);
  // 偷第二个
  const dp2 = new Array(nums.length).fill(0);

  const n = nums.length;

  dp1[0] = nums[0];
  dp1[1] = nums[0];

  dp2[0] = 0;
  dp2[1] = nums[1];

  for (let i = 2; i < n; i++) {
    if (i === n - 1) {
      // 最后一个不偷
      dp1[i] = dp1[i - 1];
    } else {
      dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + nums[i]);
    }

    dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i]);
  }

  return Math.max(dp1[n - 1], dp2[n - 1]);
};
```
