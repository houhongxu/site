# 72M 编辑距离

## 解题思路

### 思路一

动态规划

这个方程需要先考虑初始化才能总结出来

初始化，二维数组 dp 的行代表 word1，列代表 word2，dp[i][j] 代表 m 行转换成 n 列字符串需要的次数

例如'a' 'ab' 'abc'转换''是 1 2 3

所以左边框和上边框就按顺序初始化，但是直接开始是 1 开始的，所以 dp 行列都需要+1 才是 0 开始

初始化后就可以看出来，m>n 时，行数代表删除，列数代表插入，对角线代表转换

那么方程就出来了

```js
dp[i][j] =
  Math.min(
    // 删除
    dp[i - 1][j],
    // 插入
    dp[i][j - 1],
    // 替换
    dp[i - 1][j - 1]
  ) + 1;
```

另外，如果之前字母相同 word1[i - 1] === word2[j - 1]，不需要操作，那么 dp[i][j] 不变

### 代码

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
  const m = word1.length;
  const n = word2.length;

  // m+1 n+1 因为要处理空字符串的情况
  const dp = [...new Array(m + 1)].map((item) => [...new Array(n + 1)]);

  for (let i = 0; i <= m; i++) {
    dp[i][0] = i;
  }

  for (let i = 0; i <= n; i++) {
    dp[0][i] = i;
  }

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        if (!dp[i][j]) {
          dp[i][j] =
            Math.min(
              // 删除
              dp[i - 1][j],
              // 插入
              dp[i][j - 1],
              // 替换
              dp[i - 1][j - 1]
            ) + 1;
        }
      }
    }
  }

  return dp[m][n];
};
```
