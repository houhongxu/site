# 装饰器

装饰器（Decorator）本质上是**一种语法糖**，用来在**不修改原有类或方法逻辑的情况下**，动态地给它们添加额外的功能。
在 TypeScript 中，装饰器的底层其实就是**函数**，运行时被调用，用于修改类或类成员的定义。

---

### 一、原理简述

假设我们有一个类：

```ts
class UserService {
  getUser() {
    return "Tom";
  }
}
```

我们可以用装饰器包装它：

```ts
function Log(target: any, key?: string, descriptor?: PropertyDescriptor) {
  console.log("装饰器执行", target, key, descriptor);
}

@Log
class UserService {
  getUser() {
    return "Tom";
  }
}
```

这里的执行顺序是：

- `@Log` 在类定义时执行（不是实例化时）。
- `target` 是类的构造函数。
- 如果装饰方法：`key` 是方法名，`descriptor` 是属性描述符。

---

### 二、装饰器类型（以 TypeScript 为例）

1. **类装饰器**

   ```ts
   function Controller(prefix: string) {
     return function (target: Function) {
       Reflect.defineMetadata("prefix", prefix, target);
     };
   }

   @Controller("/user")
   class UserController {}
   ```

   NestJS 的 `@Controller()`、`@Module()`、`@Injectable()` 都是类装饰器。

2. **方法装饰器**

   ```ts
   function LogMethod() {
     return function (
       target: any,
       key: string,
       descriptor: PropertyDescriptor
     ) {
       const original = descriptor.value;
       descriptor.value = function (...args: any[]) {
         console.log(`[LOG] 调用 ${key}(${args.join(", ")})`);
         return original.apply(this, args);
       };
     };
   }

   class UserService {
     @LogMethod()
     getUser(id: number) {
       return `User ${id}`;
     }
   }

   new UserService().getUser(1);
   ```

3. **参数装饰器**

   ```ts
   function Param(
     target: Object,
     propertyKey: string | symbol,
     parameterIndex: number
   ) {
     console.log(
       `参数装饰器作用在 ${String(propertyKey)} 的第 ${parameterIndex} 个参数上`
     );
   }

   class Example {
     greet(@Param name: string) {}
   }
   ```

---

### 三、在 NestJS 中的应用举例

#### 1. 自定义装饰器：提取当前用户

NestJS 提供了 `createParamDecorator`，可创建参数装饰器，例如从请求中获取 JWT 解析的用户信息。

```ts
// user.decorator.ts
import { createParamDecorator, ExecutionContext } from "@nestjs/common";

export const User = createParamDecorator((data, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest();
  return request.user; // 由 AuthGuard 注入的用户信息
});
```

在控制器中使用：

```ts
@Get('profile')
getProfile(@User() user) {
  return user;
}
```

---

#### 2. 自定义方法装饰器：权限控制

```ts
import { SetMetadata } from "@nestjs/common";

export const Roles = (...roles: string[]) => SetMetadata("roles", roles);
```

结合 Guard 使用：

```ts
@UseGuards(RolesGuard)
@Get('admin')
@Roles('admin')
getAdminData() {
  return 'only admin can see this';
}
```

在 Guard 里取出：

```ts
const roles = this.reflector.get<string[]>("roles", context.getHandler());
```

---

### 四、底层机制总结

NestJS 的装饰器依托于：

- TypeScript 的装饰器特性
- `reflect-metadata` 库，用于存储/读取元数据

运行时，Nest 会扫描这些装饰器存储的元数据来自动注册控制器、注入依赖、绑定路由、加载管道、守卫等。
换句话说：**NestJS 的装饰器是它的“声明式配置系统”**，你写 `@Controller()` 或 `@Get()`，框架在背后会自动把这些信息注册到路由表或 IoC 容器中。

---

要更深入理解这一机制，可以亲手写一个迷你版本的 `@Controller` + 路由注册系统。那种“手搓框架”的体验能让装饰器原理一下子变得非常直观。是否想我帮你演示一个简单实现？
